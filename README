Introduction:
This is a very simple demo API intended to function as a basic twitter clone. It is intended to be run along side the GUI
generated by the REACT app chas-twitter-test-react

---------------------------------------------------------------------------------------------------------
Preparation:

This program can only be run on a machine with Java 9 or higher installed.

The program assumes that the user has already set up a MySql database that it can interact with. When the system starts
it will set up the necessary tables in the database for it to interact with.

After the system has been run once, it is recommended to change the line 'spring.jpa.hibernate.ddl-auto=update' in
'application.properties' to 'spring.jpa.hibernate.ddl-auto=none' to prevent the program from further changing the database

---------------------------------------------------------------------------------------------------------
Starting the program:

In order to start the program, the following parameters must be set via the terminal, or by altering the file
'application.properties'. If the parameters are not defined, the default values will be used instead.

WARNING: The GUI assumes that the program is accessible at port 8080! If this port is changed, the system will not function.

server.port:                The port which the program should run on.               Default: 8080
spring.datasource.url:      The url of the database                                 Default: jdbc:mysql://localhost:3306/my_database
spring.datasource.username: A user with correct access rights to the database.      Default: root
spring.datasource.password: password                                                Default: password

Run with maven:
  - Open terminal
  - Navigate to the project root folder, which should be ./ChasTwitterTest
  - Execute the following command. Change the parameters if necessary
    mvn spring-boot:run -Dspring-boot.run.arguments=--server.port=8080,--spring.datasource.url=jdbc:mysql://localhost:3306/my_database,--spring.datasource.username=root,--spring.datasource.password=password

---------------------------------------------------------------------------------------------------------
Database:
When the program first runs, it will setup the following tables in the MySQL database:

users {
  username: varchar
  email: varchar
  password: varchar
}

tweets {
  id: id,
  timestamp: datetime,
  tweet: varchar,
  username: varchar
}

followed_users {
  id: int,
  followedUsername: varchar,
  username: varchar
}

hibernate_sequence {
  next_val: bigint
}

---------------------------------------------------------------------------------------------------------
Available requests:

POST user:
    Inserts a new user into the database
    URL: POST <host>:<port>/user/post
    Body:
    {
      "username": <username of user>,
      "password": <password of user>,
      "email": <email of user>
    }
    Example:
        POST localhost:8080/user/post
        {
          "username": "someUsername",
          "password": "aPassword",
          "email": "Henrik@gmail.com"
        }

GET user:
    Fetches a user with specified username
    URL: GET <host>:<port>/user/get/<username>
    Example: GET http://localhost:8080/user/get/someUsername

GET all users:
    Fetches a list of all users
    URL: GET <host>:<port>/user/get/all
    Example: GET http://localhost:8080/user/get/all

GET login
  Logs in a user
  URL GET http://<host>:<port>/login?username=<username>&password=<password>
  URL GET http://localhost:8080/login?username=someUsername&password=aPassword

POST tweet:
    Inserts a new tweet from user into the database
    URL: POST <host>:<port>/tweet/post
    Body:
    {
      "username": <username of user>,
      "tweet": <the tweet>
    }
    Example:
        POST http://localhost:8080/tweet/post
        {
          "username": "someUsername",
          "tweet": "Random, stuff about some political issue"
        }

GET all tweets from user:
    Fetches a list of all tweets from a user
    URL: GET <host>:<port>/tweet/get/<username>
    Example: GET http://localhost:8080/user/get/someUsername

GET all tweets from followed users:
    Fetches a list of all tweets from the users username follows
    URL: GET <host>:<port>/tweet/get/FollowedUsersTweets/<username>
    Example: GET http://localhost:8080/tweet/get/FollowedUsersTweets/someUsername

GET all tweets:
    Fetches a list of all tweets
    URL: GET <host>:<port>/tweet/get/all
    Example: GET http://localhost:8080/user/get/all

POST follow user:
    Makes a user follow another user
    URL: POST <host>:<port>/followUser/post
    Body:
    {
      "username": <username of user>,
      "followedUsername": <username of the user to be followed>
    }
    Example:
        POST http://localhost:8080/tweet/post
        {
          "username": "someUsername",
          "followedUsername": "userIWishToFollow"
        }

DELETE unfollow user:
    Makes a user unfollow another user
    URL: POST <host>:<port>/followUser/delete
    Body:
    {
      "username": <username of user>,
      "followedUsername": <username of the user to be unfollow>
    }
    Example:
        POST http://localhost:8080/tweet/delete
        {
          "username": "someUsername",
          "followedUsername": "userINoLongerWishToFollow"
        }

GET all followed users:
    Fetches a list of showing which users follow which other users
    URL: GET <host>:<port>/followUser/get/all
    Example: GET http://localhost:8080/followUser/get/all

---------------------------------------------------------------------------------------------------------
Known issues:

The system is currently a hacker's dream as it provides virtually no security of any kind. I did not implement these
in order to save time and because the test's specification did not ask for additional security features.

The worst offenders are the following:
  - Passwords are currently stored in plaintext as opposed to being encrypted. Unacceptable in a production environment
  - All Apis are wide open and don't check the credentials of the client. Again, unacceptable for any real system.

When the GUI is opened in a browser, it's CORS policy may prevent it from accessing the API. To circumvent this problem,
a possible solution is to install a plugin to the browser that temporarily disables the CORS policy.
Another solution is creating a shortcut to Google Chrome with CORS disabled:
  - Right click on desktop, add new shortcut
  - Add the target as "[PATH_TO_CHROME]\chrome.exe" --disable-web-security --disable-gpu --user-data-dir=~/chromeTemp
  - Click OK.

If this was a full production system, the functionality APIs should be expanded into full CRUD APIs (CREATE,
READ, UPDATE, DELETE). For example, at the moment it is not possible to delete or update any users. I did
not implement these to save time as they were not needed to complete the test